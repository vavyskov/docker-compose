## docker network create --driver=overlay frontend_network;
## docker stack deploy --compose-file=docker-compose.yml traefik

version: '3.5'

#secrets:
#  ## secret name also used to name the file exposed within the container
#  ovh_endpoint:
#    ## path on the host
#    file: ./secrets/ovh_endpoint.secret
#  ovh_application_key:
#    file: ./secrets/ovh_application_key.secret
#  ovh_application_secret:
#    file: ./secrets/ovh_application_secret.secret
#  ovh_consumer_key:
#    file: ./secrets/ovh_consumer_key.secret

services:

  traefik:
    image: traefik:${TRAEFIK_VERSION:-2.1}
    container_name: traefik
    command:
      ## Traefik will listen on port 8080 by default for API request
      - --api.insecure=true
      ## Enabling docker provider
      - --providers.docker=true
      ## Do not expose containers unless explicitly told so
      - --providers.docker.exposedbydefault=false
      ## ???
      #- --providers.docker.watch=true
      #- --providers.docker.swarmmode=true
      #- --providers.docker.endpoint=unix:///var/run/docker.sock
      #- --providers.docker.swarmModeRefreshSeconds=15s
      ## Network
      - --providers.docker.network=frontend_network
      ## Traefik tries to find a binding on port to select the container
      - --providers.docker.useBindPortIP=true
      ## Traefik will listen to incoming request on the port 80 (HTTP - custom name)
      - --entrypoints.http.address=:80
      ## Traefik will listen to incoming request on the port 443 (HTTPS - custom name)
      - --entrypoints.https.address=:443

      ## Traefik will listen to incoming request on the port 3306 (MySQL - custom name)
      #- --entrypoints.mysql.address=:3306

      ## Custom certificates
      - --providers.file.directory=/etc/traefik/dynamic

      # Create mechanism (enable a TLS challenge) to generate certifiacte called "letsencrypt"
#      - --certificatesresolvers.letsencrypt.acme.tlschallenge=true
      ## The email to provide to let's encrypt
#      - --certificatesresolvers.letsencrypt.acme.email=my@email.com
      ## Tell to store the certificate on a path under our volume
#      - --certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json


      ## Enable a DNS challenge named "mydnschallenge"
      #- --certificatesresolvers.mydnschallenge.acme.dnschallenge=true
      ## Tell which provider to use
      #- --certificatesresolvers.mydnschallenge.acme.dnschallenge.provider=ovh


      ## Tell it to use our predefined entrypoint named "http"
      #- --certificatesresolvers.myhttpchallenge.acme.httpchallenge.entrypoint=http
      #- --certificatesresolvers.myhttpchallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory
      #- --certificatesresolvers.myhttpchallenge.acme.email=postmaster@mydomain.com
      #- --certificatesresolvers.myhttpchallenge.acme.storage=/letsencrypt/acme.json

      ## Log level: ERROR (default) | DEBUG | PANIC | FATAL | WARN | INFO
      #- --log.level=DEBUG

      #- --certificatesResolvers.mytlschallenge.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory

    ## expose the predefined secret to the container by name
#    secrets:
#      - ovh_endpoint
#      - ovh_application_key
#      - ovh_application_secret
#      - ovh_consumer_key
#    environment:
      #- OVH_ENDPOINT=xxx
      #- OVH_APPLICATION_KEY=xxx
      #- OVH_APPLICATION_SECRET=xxx
      #- OVH_CONSUMER_KEY=xxx
#      - OVH_ENDPOINT_FILE=/run/secrets/ovh_endpoint
#      - OVH_APPLICATION_KEY_FILE=/run/secrets/ovh_application_key
#      - OVH_APPLICATION_SECRET_FILE=/run/secrets/ovh_application_secret
#      - OVH_CONSUMER_KEY_FILE=/run/secrets/ovh_consumer_key
    volumes:
      ## Traefik can listen to the Docker events
      - /var/run/docker.sock:/var/run/docker.sock:ro
      ## Custom certificates (set path also in dynamic/certificates.yml)
#      - /etc/ssl/path:/etc/ssl/path:ro
      - ./dynamic/certificates.yml:/etc/traefik/dynamic/certificates.yml:ro
      ## Create a letsencrypt dir within the folder where the docker-compose file is
      #- ./letsencrypt:/letsencrypt
    ports:
      - target: 80
        published: 80
      - target: 443
        published: 443
      - target: 8080
        published: ${TRAEFIK_PORT:-8080}
      - target: 9000
        published: 9000
    networks:
      - frontend_network
    deploy:
#      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
#          - node.hostname == serverhostname
#          - node.labels.traefik == true
#        preferences:
#          - spread: node.id
#    deploy:
#      mode: global
#      placement:
#          constraints:
#            - node.platform.os == linux
#      restart_policy:
#        condition: on-failure
    ## Dynamic section
    labels:
      - traefik.enable=true
      - traefik.http.services.traefik.loadbalancer.server.port=8080
      #- traefik.http.services.traefik.loadbalancer.passhostheader=true
      - traefik.http.routers.traefik.service=traefik
      ## The router 'traefik' will forward request to service api@internal
      #- traefik.http.routers.traefik.service=api@internal

      - traefik.http.routers.traefik.rule=Host(`traefik.example.com`)
      #- traefik.http.routers.traefik.rule=Host(`traefik.example.com`) && Path(`/traefik`)
      #- traefik.http.routers.traefik.rule=Host(`traefik.example.com`) && PathPrefix(`/traefik`)

#      - traefik.http.routers.traefik.tls=true
#      - traefik.http.routers.traefik.entrypoints=https

      ## Tell Traefik, that for router 'traefik' should use following middleware
      ## BasicAuth (BCrypt or MD5 not SHA1) - https://www.htaccesstools.com/htpasswd-generator/
      - traefik.http.routers.traefik.middlewares=authtraefik
      ## In password type $ as $$
      - traefik.http.middlewares.authtraefik.basicauth.users=traefik:$$2y$$10$$MxGYZbTQLhcfs40HR9wkLuzqYCwCtjVzGfhguf0RTk6sQQrRQqJS2
      #- traefik.http.middlewares.authtraefik.basicauth.users=test:$$apr1$$H6uskkkW$$IgXLP6ewTrSuBkTrqE8wj/
      #- traefik.http.middlewares.authtraefik.basicauth.users=admin:$$2y$$05$$1OX5jZ1Kpm/iVKE8tgUhu.STmPkgi0lLxVeP5yEcRioFdV4mcgdTu


      ## Middlewares: Strip prefix
      #- traefik.http.middlewares.traefik-strip-prefix.stripprefix.prefixes=/traefik
      #- traefik.http.middlewares.traefik-strip-prefix.stripprefix.forceslash=false
      #- traefik.http.routers.traefik.middlewares=traefik-strip-prefix@docker


      #- "traefik.http.middlewares.secured.chain.middlewares=https-only,known-ips,auth-users"
      #- "traefik.http.middlewares.auth-users.basicauth.users=test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/"
      #- "traefik.http.middlewares.https-only.redirectscheme.scheme=https"
      #- "traefik.http.middlewares.known-ips.ipwhitelist.sourceRange=192.168.1.7,127.0.0.1/32"


      ## Global redirection - this creates the redirect middleware and redirects all http requests to https
#      - traefik.http.routers.http-catchall.entrypoints=http
#      - traefik.http.routers.http-catchall.rule=hostregexp(`{host:.+}`)
      #- traefik.http.routers.http-catchall.rule=HostRegexp(`{any:.*}`)
#      - traefik.http.routers.http-catchall.middlewares=redirect-to-https
#      - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https


#      - traefik.http.middlewares.secured.chain.middlewares=foo-add-prefix,auth
      
      #- traefik.http.middlewares.add-foo.addprefix.prefix=/foo

      ## Create a middleware named `foo-add-prefix`
#      - "traefik.http.middlewares.foo-add-prefix.addprefix.prefix=/traefik/dashboard"
      ## Apply the middleware named `foo-add-prefix` to the router named `traefik`
#      - "traefik.http.routers.traefik.middlewares=foo-add-prefix@docker"

networks:
  frontend_network:
    external: true
#  frontend_network:
#    driver: overlay
#    name: frontend_network
#    attachable: true
#    #driver_opts:
#      #encrypted: true